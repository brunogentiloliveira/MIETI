/*
 * Note: this file originally auto-generated by mib2c
 * using mib2c.scalar.conf
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "hostMusicMIB.h"
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>

/** Initializes the hostMusicMIB module */

int hmPlayMusic;
int hmPlayStatus;
int len;//numero de musicas
int son;

typedef struct Playlist {
  int musica;
  struct Playlist *next;
} stPlaylist;

stPlaylist *cabeca=NULL;
char *instantMusic[1024];

void escreverPlaylist(){
    char line[10];
    stPlaylist *atual = cabeca;

    FILE *filep = fopen("/etc/hostmusicmib.conf/playlistTable.conf", "w");
    while (atual != NULL){
        memset(line, '\0',10);
        sprintf(line, "%d\n", atual->musica);
        fwrite(line,1,strlen(line),filep);
        atual = atual -> next;
    }
    fclose(filep);
}

void playSong(){
    hmPlayStatus = 1;
	if ((son=fork()) == 0) {
		if (execlp("cvlc", "cvlc", "--no-video", "--play-and-exit", instantMusic[hmPlayMusic], NULL)<0) {
			perror("Abortar: Erro no exec\n");
			exit(-1);
		}
	}
}

void removerMusica(){
    hmPlayMusic = cabeca->musica;
    cabeca = cabeca->next;
}

void sigchld_handler(int sig){
    int status, p;
    p = wait(&status);
    if (p==son){
        son = 0;
        if (cabeca != NULL){
            removerMusica();
            signal(SIGCHLD, sigchld_handler);
            playSong();
            escreverPlaylist();
        }else{
            hmPlayMusic = 0;
            hmPlayStatus = 0;
        }
    }else{
        /* ativar sinal */
        signal(SIGCHLD, sigchld_handler);
    }
}

void adicionarMusica(int m){
    if (hmPlayStatus == 0){
        hmPlayMusic = m;
        signal(SIGCHLD, sigchld_handler);
        playSong();
    }else{
        stPlaylist *temp = (stPlaylist*) malloc(sizeof(stPlaylist));
        temp->musica = m;
        if (cabeca==NULL) {
            temp->next=cabeca;
            cabeca=temp;
        }else{
            stPlaylist *atual=cabeca;
            while (atual->next != NULL) {
                atual=atual->next;
            }
            atual->next=temp;
        }
        escreverPlaylist();
    }
}

void limparPlaylist(){
    char n[2] = "\n";
    FILE *filep = fopen("/etc/hostmusicmib.conf/playlistTable.conf", "w");
    fwrite(n,1,sizeof(n),filep);
    fclose(filep);

    while (cabeca != NULL){
       stPlaylist *tmp = cabeca;
       cabeca = cabeca->next;
       free(tmp);
    }

}

int readMusic(){
    FILE *filep;
    char line[256];
    filep = fopen("/etc/hostmusicmib.conf/musicList.conf", "r");
    if(NULL ==  filep) {
        return MFD_RESOURCE_UNAVAILABLE;
    }
    while( 1 ) {
        do {
            if (!fgets(line, sizeof(line), filep)) {
                fclose(filep);
                filep = NULL;
            }
        } while (filep && (line[0] == '\n'));

        if(NULL == filep)   break;
        line[strlen(line)-1]='\0';
        
        char* token;
        char* rest = line; 
        int i = 0;
        while ((token = strtok_r(rest, ";", &rest))) {
            if (i==0){
                i = atoi(token);
                len = i;
                instantMusic[i] = (char *) malloc(256);
                //alocar memoria
            }else{
                strcpy(instantMusic[i],token);
                //musica
            }
        }
    }
    if(NULL != filep)   fclose(filep);
    return MFD_SUCCESS;
}

void
init_hostMusicMIB(void)
{
    const oid hmPlayMusic_oid[] = { 1,3,6,1,3,2020,6,2 };
    const oid hmAddtoPlaylist_oid[] = { 1,3,6,1,3,2020,6,3 };
    const oid hmPlayStatus_oid[] = { 1,3,6,1,3,2020,6,4 };

  DEBUGMSGTL(("hostMusicMIB", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("hmPlayMusic", handle_hmPlayMusic,
                               hmPlayMusic_oid, OID_LENGTH(hmPlayMusic_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("hmAddtoPlaylist", handle_hmAddtoPlaylist,
                               hmAddtoPlaylist_oid, OID_LENGTH(hmAddtoPlaylist_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("hmPlayStatus", handle_hmPlayStatus,
                               hmPlayStatus_oid, OID_LENGTH(hmPlayStatus_oid),
                               HANDLER_CAN_RONLY
        ));

    readMusic();
}

int
handle_hmPlayMusic(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &hmPlayMusic,
                                     sizeof(hmPlayMusic));
            break;

        case MODE_SET_RESERVE1:
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* se nao pertencer a nr de musicas*/
            if ((int )*(requests->requestvb->val.integer)<0 || (int )*(requests->requestvb->val.integer)>len) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            hmPlayMusic = 0;
            break;

        case MODE_SET_ACTION:
            if ((int )*(requests->requestvb->val.integer) == 0){
                if(cabeca != NULL){
                    limparPlaylist();
                }
                kill(son, SIGKILL);
            }else{
                if (hmPlayStatus == 0){
                    hmPlayMusic = (int )*(requests->requestvb->val.integer);
                    signal(SIGCHLD, sigchld_handler);
                    playSong();
                }else{
                     netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
                }
            }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            hmPlayMusic = 0;
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_hmPlayMusic\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_hmAddtoPlaylist(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
   
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &hmPlayStatus,
                                     sizeof(hmPlayStatus));
            break;

        
        case MODE_SET_RESERVE1:
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
           /* se nao pertencer a nr de musicas*/
            if ((int )*(requests->requestvb->val.integer) <= 0 || (int )*(requests->requestvb->val.integer)>len) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            adicionarMusica((int )*(requests->requestvb->val.integer));
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_hmAddtoPlaylist\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_hmPlayStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &hmPlayStatus,
                                     sizeof(hmPlayMusic));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_hmPlayStatus\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
